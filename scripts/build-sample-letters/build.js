const path = require('path');
const util = require('util');
const fs = require('fs');
const deepmerge = require('deepmerge');
const matcher = require('matcher');
const carbone = require('carbone');
const renderCarbone = util.promisify(carbone.render).bind(carbone);
const { templatify } = require('./util');

// This script generates the sample letters in the various formats from our request templates, which was previously done
// manually (and a source of great pain and suffering).

// It would be great to move the template translations into Weblate, have that be the single source of truth for our
// templates and then have everything else be generated by this script. Unfortunately, that is not possible right now as
// there is a license mismatch between the templates (CC0) and the other translations (MIT).
// As such, the templates are unfortunately still duplicated in the `data` repository and cannot be translated easily
// yet.

// Should we ever find a way to move these translations to Weblate, we need to remember that the translations here are
// currently *NOT* an exact copy of the templates in `data`. Some line breaks are different.

const languages = fs
    .readdirSync(path.join(__dirname, '..', '..', 'content'), { withFileTypes: true })
    .filter((i) => i.isDirectory())
    .map((d) => d.name);

const _i18n = require('./res/i18n.json');
const i18n = languages.reduce((acc, l) => ({ ...acc, [l]: deepmerge(_i18n.en, _i18n[l] || {}) }), {});

const _t = (lang, key) =>
    key.includes('*')
        ? matcher(Object.keys(i18n[lang]), [key])
              .sort()
              .map((k) => i18n[lang][k])
        : i18n[lang][key];

// At the moment, the `regular_template()` function seems quite pointless as all templatees are regular templates right
// now. However, if we manage to have this be the single source of truth for our templates one day (see above), we will
// also have other template types. For example, `access-tracking` is mostly a copy of the `access-default` template with
// only a few changes.
// With that, we would be able to avoid having to duplicate the entire template in the translations (as it is sadly the
// case right now) and could instead define a custom template that only replaces the respective lines but inherits the
// rest from `access-default`.
const regular_template = (t, type) => ({
    subject: t(`${type}-subject`),
    body: [
        t('common-body-salutation'),
        ...t(`${type}-body-*`),
        t('common-body-id-data'),
        t('common-body-deadline'),
        t('common-body-thanks'),
        t('common-body-bye'),
    ],
    doc_title: t(`${type}-doc-title`),
    filename: t(`${type}-filename`),
});
const templates = (t) => ({
    common: {
        explanation: t('sample-explanation'),
        sender_address: t('sample-sender-address'),
        recipient_address: t('sample-recipient-address'),
        reference_line: t('sample-reference-line'),
        your_name: t('sample-your-name'),
        page: t('page'),
        of: t('of'),

        variables: {
            id_data: t('common-var-id-data'),
            rectification_data: t('rectification-var-rectification-data'),
            erasure_data: t('erasure-var-erasure-data'),
        },

        doc_title: t('common-doc-title'),
        doc_desc: t('common-doc-desc'),
    },

    access: regular_template(t, 'access'),
    erasure: regular_template(t, 'erasure'),
    objection: regular_template(t, 'objection'),
    rectification: regular_template(t, 'rectification'),
});
const flags = { runs: 0, has_fields: 1, data_portability: 2, erase_all: 2, erase_some: 2 };

const out_dir = path.join(__dirname, '..', '..', 'static', 'downloads');

(async () => {
    carbone.set({ templatePath: path.join(__dirname, 'res') });

    // TODO: Replace this with `languages` once we have the translations for all languages here.
    for (const lang of ['de', 'en']) {
        const t = (key) => _t(lang, key);
        const common_template = templates(t).common;

        for (const type of ['access', 'erasure', 'objection', 'rectification']) {
            const specific_template = templates(t)[type];
            const data = {
                ...common_template,
                ...specific_template,
                // I have not found a way to directly insert string array items, so we map them to objects with a string
                // property. *shrug*
                body: specific_template.body
                    .map((p) => templatify(p, flags, common_template.variables))
                    .map((p) => ({ text: p.trim() })),
            };

            for (const format of ['ott', 'dotx']) {
                const file = await renderCarbone(`template.${format}`, data, {
                    // Carbone doesn't officially support the template format variants, so we pretend that we're using
                    // ODT and DOCX instead of OTT and DOTX, respectively. From what I have seen, this seems to only be
                    // relevant for proper line breaks.
                    extension: format === 'dotx' ? 'docx' : 'odt',
                });
                const out_path = path.join(out_dir, `${data.filename}.${format}`);
                fs.writeFileSync(out_path, file);
            }
        }
    }
})();
