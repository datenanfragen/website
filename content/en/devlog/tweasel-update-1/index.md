{
    "title": "Tweasel update #1: Building libraries and automating setup",
    "type": "devlog",
    "date": "2023-05-31T13:37:00+02:00",
    "description": "We update you on our progress with the tweasel project. We have released first versions of our libraries and tools for instrumenting and analyzing mobile apps and their traffic. We have worked on automating the installation of dependencies and device setup. We have launched our documentation website for tracking endpoints and their data. We have also given a talk at FireShonks event and a presentation to the EDPB tech advisory board.",
    "authors": [ "baltpeter" ]
}

With the [tweasel project](https://github.com/tweaselORG), we want to build a web app that detects privacy violations in mobile apps on Android and iOS. Users can select an app from the app stores and we will analyze its network traffic and consent dialogs. We will show a report to the user and offer to generate a complaint under the GDPR and ePrivacy Directive with the collected evidence. Lorenz and I are working on this thanks to [NLnet funding](https://nlnet.nl/project/TrackingWeasel/).

To keep you up to date on everything we're doing, we'll start doing biweekly update posts, where we go into the progress we've made and features we've added to our tools and libraries, but also any interesting technical challenges we've solved. This first one is going to be a bit longer, since we have some catching up to do. Strap in.

## Appstraction

> [Appstraction](https://github.com/tweaselORG/appstraction) is an abstraction layer for common instrumentation functions on Android and iOS. It allows you to install, uninstall, start, stop apps and configure their permissions, as well as manage device settings like emulator snapshots, clipboard, proxy, and certificates. Appstraction can also be used for purposes other than mobile privacy.

* We released the [first version of appstraction](https://github.com/tweaselORG/appstraction/releases/tag/v0.1.1) at the end of March. This initial version was based on the [platform layer](https://github.com/baltpeter/thesis-mobile-consent-dialogs/blob/5cfd174035fe76070fd8000c0d38578178d205da/src/common/platform.ts) I wrote for my [master's thesis](https://benjamin-altpeter.de/doc/thesis-consent-dialogs.pdf), but we already added quite a lot of useful improvements, in addition to thorough documentation:
  * We have a [capability system](https://github.com/tweaselORG/appstraction/issues/5) that allows users to disable functionality that requires special capabilities like root rights or Frida if they don't want or need those features.
  * You can [granularly choose which permissions to grant or deny](https://github.com/tweaselORG/appstraction/issues/15).
  * I added support for managing proxies and certificate authorities on [Android](https://github.com/tweaselORG/appstraction/pull/27) and [iOS](https://github.com/tweaselORG/appstraction/pull/42).
  
    On Android, everything is completely automated and works on both emulators and physical devices. System CAs are stored in `/system/etc/security/cacerts` but since Android 10, `/system` is only mounted as read-only and cannot be written to even with root rights. To circumvent that, we're using a [clever workaround by HTTP Toolkit](https://github.com/tweaselORG/meta/issues/18): While writing to `/system/etc/security/cacerts/` is not possible, you can mount a tmpfs over `/system/etc/security/cacerts/`, which you can then write to.  
    Instead of a global system proxy, you can use WireGuard, which [regular apps can't get around](https://github.com/tweaselORG/meta/issues/19) and which allows you to precisely filter which apps to tunnel. WireGuard is even [automatically installed](https://github.com/tweaselORG/appstraction/issues/38) and [configured](https://github.com/tweaselORG/meta/issues/19#issuecomment-1441842333) on the device if enabled.
    
    Meanwhile on iOS, the [method for programmatically configuring CAs](https://github.com/tweaselORG/appstraction/issues/44) through an SQLite database I reverse-engineered is incomplete and requires a [one-time manual action by the user](https://github.com/tweaselORG/appstraction/issues/44#issuecomment-1466146004). Lorenz is currently investigating a [different method using configuration profiles](https://github.com/tweaselORG/appstraction/issues/44#issuecomment-1545880084).  
    We currently also only support [setting a system proxy on iOS](https://github.com/tweaselORG/appstraction/issues/25#issuecomment-1438855786) but no WireGuard ([yet?](https://github.com/tweaselORG/meta/issues/21)).
  * I also added functions to [configure an app's battery optimization settings](https://github.com/tweaselORG/appstraction/issues/34) (currently Android-only), (force-)stop apps ([Android](https://github.com/tweaselORG/appstraction/issues/36) and [iOS](https://github.com/tweaselORG/appstraction/issues/37)), and to check whether an app is already installed on the device ([Android](https://github.com/tweaselORG/appstraction/issues/40) and [iOS](https://github.com/tweaselORG/appstraction/issues/41)).
  * Split APKs often come with splits for various architectures. Trying to install these on a device that doesn't support some of of these architectures [will fail](https://github.com/tweaselORG/appstraction/issues/4). To make it easier for the user, we [automatically filter the splits to only install the compatible ones](https://github.com/tweaselORG/appstraction/pull/52).
  * There is barely any device setup necessary on Android as we're [automatically installing Frida if necessary](https://github.com/tweaselORG/appstraction/issues/39).
* [Version 0.2.0](https://github.com/tweaselORG/appstraction/releases/tag/v0.2.0) brought support for Windows. This didn't [require any major changes](https://github.com/tweaselORG/appstraction/pull/61) and was mostly just annoying (different line endings, no grep, `ideviceinstaller` has a different CLI). Also, we are now using `NodeSSH`, which removes `sshpass` as a dependency.
* Since then, we've made a bunch of changes that will be released soon:
  * Lorenz [added support](https://github.com/tweaselORG/appstraction/pull/64) for installing apps from [`.xapk`](https://github.com/tweaselORG/appstraction/issues/63), [`.apkm`, and `.apks`](https://github.com/tweaselORG/appstraction/issues/66) files, which are used by the common APK download portals APKPure and APKMirror. With that, we also support [installing `.obb` files alongside `.apks`](https://github.com/tweaselORG/appstraction/issues/65). While [deprecated](https://android-developers.googleblog.com/2020/11/new-android-app-bundle-and-target-api.html), some older apps (especially games) still need those to work correctly. I added [support for parsing the metadata of these custom bundle formats](https://github.com/tweaselORG/appstraction/issues/67).
  * We are trying to get rid of as many setup steps as possible. To that end, I [automated the installation of the Android developer tools](https://github.com/tweaselORG/appstraction/issues/68). For that, I created a separate library called [andromatic](https://github.com/tweaselORG/andromatic) that can also be used by others. With it, you can just call tools like `adb` from Node.js (including requesting a specific version) and andromatic will make sure it is installed:

    {{< video name="andromatic-demo.mp4" alt="Screenrecording of how andromatic can be used. In multiple examples, Android developer tools are called from JavaScript without being installed manually. Each time, we see that the output of the tool is displayed. The first example calls runAndroidDevTools('adb', ['devices']). When run, we see how a cache directory for andromatic is being filled with the necessary components of the Android SDK, namely a licenses, cmdline-tools, and platform-tools folder. Next, the command is changed to aapt. This time, a build-tools folder is created in the cache directory. Inside, there is a folder called 33.0.2. Finally, the code is changed to runAndroidDevTool({ tool: 'aapt', packageVersion: '28.0.3' }). Running this creates a folder called 28.0.3 alongside the existing one in build-tools." >}}
  * We also did the same thing for our Python dependencies. Lorenz [first implemented a postinstall script for this in cyanoacrylate](https://github.com/tweaselORG/cyanoacrylate/issues/9), but we also needed the functionality in appstraction. So I created [autopy](https://github.com/tweaselORG/autopy), a library for depending on Python packages from JavaScript that will automatically manage a venv and download Python and pip dependencies. It uses the very handy static Python builds provided by [python-build-standalone](https://python-build-standalone.readthedocs.io/en/latest/index.html).
  * Still on the subject of fewer dependencies, [I got rid of OpenSSL](https://github.com/tweaselORG/appstraction/issues/79). We only needed that to calculate the `subject_hash_old` of the CAs we want to install on Android. With the help of Bing Chat, I was able to implement that in JS.
  * Lorenz is investigating switching from [libimobiledevice](https://libimobiledevice.org/) to [pymobiledevice3](https://github.com/doronz88/pymobiledevice3) or [go-ios](https://github.com/danielpaulus/go-ios). These have more features (most crucially, the ability to install configuration profiles) and we could install them automatically (my [quick attempt at doing that with libimobiledevice](https://github.com/tweaselORG/appstraction/issues/71) was not successful).
  * Lorenz has also started work on [automating the setup of iOS devices](https://github.com/tweaselORG/appstraction/issues/59), installing all the tweaks we need using `apt` through an SSH session.

## Cyanoacrylate

> [Cyanoacrylate](https://github.com/tweaselORG/cyanoacrylate) is a toolkit for large-scale automated traffic analysis of mobile apps on Android and iOS. It uses mitmproxy to capture the HTTP(S) traffic of apps in HAR format and appstraction to instrument physical devices, or emulators for Android. Cyanoacrylate handles the management of certificate authorities and WireGuard mitmproxy setup automatically. It is designed to analyze the tracking behavior of mobile apps.

* The [first version of cyanoacrylate](https://github.com/tweaselORG/cyanoacrylate/releases/tag/v0.1.0) was released at the end of March. It featured a fully automatic mitmproxy setup, Android emulator control and Python environment installation. We are using the [`har_dump.py` script](https://github.com/mitmproxy/mitmproxy/blob/main/examples/contrib/har_dump.py) to export the traffic from mitmproxy as a `.har` file and Lorenz wrote a [mitmproxy script](https://github.com/tweaselORG/cyanoacrylate/issues/5) to communicate its events to JavaScript. This version only supported Android.
* In [version 0.2.0](https://github.com/tweaselORG/cyanoacrylate/releases/tag/v0.2.0), we make use of WireGuard’s feature to only tunnel traffic of specific apps and allow you to configure the WireGuard app filtering in the options. By default, if you do a traffic collection on an app analysis, we only collect that app's traffic. That way, you don't have to worry about filtering out background traffic anymore.

  I implemented this by [manipulating the internal config files of the WireGuard app](https://github.com/tweaselORG/cyanoacrylate/issues/11) on Android.
* In [version 0.3.0](https://github.com/tweaselORG/cyanoacrylate/releases/tag/v0.3.0), Lorenz implemented support for [traffic collection on iOS devices](https://github.com/tweaselORG/cyanoacrylate/issues/10). This currently uses an HTTP(S) proxy (unlike on Android, where we use WireGuard) and cannot filter the traffic of individual apps. Instead, we currently always record the entire system's traffic.
* Finally, with [version 0.4.0](https://github.com/tweaselORG/cyanoacrylate/releases/tag/v0.4.0), we added [Windows support for cyanoacrylate](https://github.com/tweaselORG/meta/issues/25) and simplified the setup a little.


## TrackHAR and trackers.tweasel.org

> [TrackHAR](https://github.com/tweaselORG/TrackHAR) is a library for detecting tracking data transmissions from traffic in HAR format. It uses custom adapters to handle different tracking endpoints and extract the transmitted data. TrackHAR also aims to produce outputs that can be used to generate human-readable documentation of the tracking data. This documentation is hosted at [trackers.tweasel.org](https://trackers.tweasel.org/), a wiki that explains how TrackHAR recognizes and decodes the requests, and provides some sample information from research data.

* TrackHAR had its [first release](https://github.com/tweaselORG/TrackHAR/releases/tag/v0.1.0) in April. With that, we have laid down the [design and schema for the adapters](https://github.com/tweaselORG/meta/issues/23) and implemented the basic functionality. [Most](https://github.com/tweaselORG/TrackHAR/issues/3) of the [adapters from my master's thesis](https://github.com/baltpeter/thesis-mobile-consent-dialogs/blob/5cfd174035fe76070fd8000c0d38578178d205da/src/common/extract-request-data.ts) are [ported over](https://github.com/tweaselORG/TrackHAR/pull/2) but have received only limited additional testing and checking so far. Also, the documentation for the `containedDataPaths` is still lacking behind what we are aiming for.
* The [adapter-based matching approach](https://github.com/tweaselORG/TrackHAR#trackhar) TrackHAR primarily uses necessarily means that a significant portion of requests will be unprocessed (as we can't write an adapter for every possible endpoint, especially developer-/app-specific ones). To alleviate that somewhat, [I implemented indicator matching](https://github.com/tweaselORG/TrackHAR/issues/6) as an (optional) fallback. With indicator matching, the user can provide an object that maps data types to honey data like this:

  ```js
  {
      localIp: ['10.0.0.2', 'fd31:4159::a2a1'],
      idfa: '6a1c1487-a0af-4223-b142-a0f4621d0311'
  }
  ```
  
  TrackHAR then searches for these values in the requests. In addition to string matching in plain text, we also support searching in [base64-](https://github.com/baltpeter/base64-search) and URL-encoded text. [Support for additional encodings and hashes is planned](https://github.com/tweaselORG/TrackHAR/issues/14).
* In April, we also launched Lorenz' [initial implementation](https://github.com/tweaselORG/tracker-wiki/pull/1) of [trackers.tweasel.org](https://trackers.tweasel.org/). This documentation is generated completely automatically from the adapters in TrackHAR. We are even [creating a human-readable description of the decoding steps](https://github.com/tweaselORG/tracker-wiki/issues/2). I also included [static example values](https://github.com/tweaselORG/tracker-wiki/issues/3) of the actual data transmitted to the tracking endpoints based on the data from my master's thesis. Ultimately, we want to have a constantly-updated public database of tracking requests and dynamically list examples of observed values for each data path.   
  We hope that this will become a valuable resource for people who want to dig deeper into tracking.
  
## CLI

> [Tweasel CLI](https://github.com/tweaselORG/cli) is a command-line tool that allows you to instrument and analyze mobile apps and their traffic using the tweasel project libraries. You can record the traffic of an Android or iOS app in HAR format (based on cyanoacrylate), and detect tracking data transmissions from the traffic (based on TrackHAR). Tweasel CLI provides a convenient wrapper around these libraries for common use cases, so you don’t have to write any code.

* In April, we also released the [first version](https://github.com/tweaselORG/cli/releases/tag/v0.1.0) of our CLI (the implementation of which was [more painful than it should have been…](https://github.com/tweaselORG/cyanoacrylate/issues/15)). This initial release supports two commands:

  With `record-traffic`, you can record the traffic of an Android or iOS app in HAR format. Through command line arguments, you can configure various aspects of the traffic collection like a timeout and whether to record only the traffic of one app or the entire system.
  
  With `detect-tracking`, you can then detect tracking data transmissions from traffic in HAR format (whether recorded with a tweasel tool or otherwise). The traffic in the specified HAR file will be analyzed using TrackHAR. The detected tracking data can be output as JSON or as a human-readable table:

  {{< img name="cli-detect-tracking.png" alt="Screenshot of running the detect-traffic command on a HAR file recorded from de.check24.check24.har. Two POST requests are shown, with a table of the detected data transmissions underneath, each with a property, context, path, and value. The first request is to app.adjust.net.in and transmitted appId, appVersion, idfa, otherIdentifiers, language, model, osName, osVersion, country, manufacturer, screenWidth, and screenHeight. The second request is to app-measurement.com and transmitted appId, appVersion, idfa, osName, and osVersion." >}}
  
* Since then, I made two more changes that are not released yet (both requested by Malte):
  * I've implemented an ["interactive timeout"](https://github.com/tweaselORG/cli/issues/7). If the user doesn't provide an explicit `--timeout` flag, we wait until they manually stop the traffic recording. I think the CLI is more likely to be used for manual analysis, so this makes more sense as a default.
  
    I also added support for multiple traffic collections. With a new `--multiple-collections` flag, after each time the user stops an interactive timeout, we ask them to enter a name to start a new traffic collection or leave it empty to stop. This is really useful for analyzing apps with consent dialogs. This way, you can easily do a manual analysis and record the traffic from before and after an interaction with the consent dialog separately.
  
    {{< video name="cli-record-traffic-multiple-collections.mp4" alt="Screenrecording of using the record-traffic command with the --multiple-collections flag. The user is asked to enter a name for the first traffic collection and chooses 'initial', the CLI then sets up and starts and installs the app. After a moment, it prompts 'Press enter to stop the traffic collection'. After the user does that, a file called otto-initial.har is saved in the specified output directory. The CLI then prompts: 'Enter a name for the next traffic collection (leave empty to stop).' The user enters 'accepted'. When the user again presses enter at the 'Press enter to stop the traffic collection' prompt, a file called otto-accepted.har is created. Now, the user just presses enter at the 'Enter a name for the next traffic collection' prompt and the CLI stops." >}}
  * I also displayed the ["setting up" steps more granularly](https://github.com/tweaselORG/cli/issues/8):
  
    {{< img name="cli-record-traffic-substeps.png" alt="Screenshot of the output of the record-traffic command. showing granular substeps for the first 'Setting up…' step that is displayed as in progress: 'Starting analysis…' (done), 'Checking tracking domain resolution…' (skipped), 'Waiting for device…' (in progress), 'Checking device connecting and setting up…', 'Starting app analysis…' (last two not started yet). The following first-level steps are: 'Installing app…', 'Starting app…', 'Collecting traffic…', 'Stopping app…', 'Cleaning up…'" >}}

## Everything else

* Just at the end of last year, we gave a talk at the FireShonks year-end event. We talked about how mobile apps track us and what data they send to third parties. We showed how we analyzed thousands of apps automatically and what we found out. We also explained the legal framework of tracking in the EU and why most apps and consent dialogs don’t comply with it. [The talk was recorded](https://media.ccc.de/v/fire-shonks-2022-49115-tracking-in-apps-ist-das-legal-eine-bersicht-ber-die-mobile-trackinglandschaft) (it was in German but there is an English live dub available).
* We also have a [parse-tunes](https://github.com/tweaselORG/parse-tunes) library for fetching select data on iOS apps from the Apple App Store via undocumented internal iTunes APIs. I wrote a [Mastodon thread](https://chaos.social/@dev_at_datarequestsORG/109743813006175742) on that already back in January.
* Our explicit goal is to make our libraries and tools not just for us, both also for other NGOs, data protection authorities, researchers, etc. In April, we gave a [presentation](https://www.datarequests.org/verein/event/edpb-expert-talk-2023/) before the tech advisory board of the European Data Protection Board (EDPB) about our results and the tools we developed for mobile app tracking research. The meeting was not recorded but our [slides](https://static.dacdn.de/talks/slides/2023-04-17-edpb-expert-talk.pdf) are of course available.  
  We'll also be giving a training course on how to use our tools for a German authority next month. And we're already in contact with two other organizations fighting against tracking to work together on this issue. If you're also interested in collaborating, please [reach out](https://www.datarequests.org/contact/)! We are more than happy to help you use our tools, implement feature requests, etc.
